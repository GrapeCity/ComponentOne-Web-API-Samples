<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
		Version 1.3
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
		<resheader name="version">1.3</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
		<data name="Name1">this is my long string</data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
			[base64 mime encoded serialized .NET Framework object]
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
			[base64 mime encoded string representing a byte array form of the .NET Framework object]
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
			: System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>1.3</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="StorageUploadPOST_Parameters" xml:space="preserve">
    <value>Parameters</value>
  </data>
  <data name="StorageUploadPOST_Upload" xml:space="preserve">
    <value>Upload</value>
  </data>
  <data name="StorageUploadPOST_Parameter" xml:space="preserve">
    <value>Parameter</value>
  </data>
  <data name="StorageUploadPOST_Value" xml:space="preserve">
    <value>Value</value>
  </data>
  <data name="StorageUploadPOST_Description" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="StorageUploadPOST_Path" xml:space="preserve">
    <value>path</value>
  </data>
  <data name="StorageUploadPOST_PathText" xml:space="preserve">
    <value>The file path in storage.</value>
  </data>
  <data name="StorageUploadPOST_File" xml:space="preserve">
    <value>file</value>
  </data>
  <data name="StorageUploadPOST_FileText" xml:space="preserve">
    <value>The upload file. (for demo, please choose a .xlsx file)</value>
  </data>
  <data name="StorageUploadPOST_RequestUrl" xml:space="preserve">
    <value>Request Url</value>
  </data>
  <data name="StorageUploadPOST_ResponseData" xml:space="preserve">
    <value>Response Data</value>
  </data>
  <data name="StorageUploadDELETE_DELETE" xml:space="preserve">
    <value>Delete</value>
  </data>
  <data name="StorageUploadPOST_PathTextAWS" xml:space="preserve">
    <value>- AWS: AWS/test.xlsx&lt;/br&gt;

step 1: you need prepare value for following 3 keys in the Web.config.&lt;/br&gt;

AccessTocken&lt;/br&gt;
SecretKey&lt;/br&gt;
BucketName&lt;/br&gt;
step 2: open WebApiExplorer project and navigate to Storage api section.&lt;/br&gt;

step 3: change "test.xlsx" to your file name you want to post.&lt;/br&gt;
NOTE: if using List Api, need change "test1" to your sub folder path.</value>
  </data>
  <data name="StorageUploadPOST_PathTextAzure" xml:space="preserve">
    <value>- Azure : The demo uses the file path as "Azure/demostoragepdfcontainer/test.xlsx"&lt;/br&gt;

You need to use your account to update the Azure connection string in the sample &lt;/br&gt;by following these steps:&lt;/br&gt;

step 1: login to your Azure account.&lt;/br&gt;

step 2: create a container and generate connection string for this container.&lt;/br&gt;

step 3: use the connection string created in step 2 to put into &lt;/br&gt;AzureStorageConnectionString key value in the Web.config.&lt;/br&gt;

step 4: open WebApiExplorer project and navigate to Storage api section.&lt;/br&gt;

step 5: change "demostoragepdfcontainer" to your container name.&lt;/br&gt;

step 6: change "test.xlsx" to your file name you want to post.&lt;/br&gt;
NOTE: if using List Api, need change "test1" to your sub folder path.</value>
  </data>
  <data name="StorageUploadPOST_PathTextDropBox" xml:space="preserve">
    <value>DropBox : DropBox/C1WebApi/test.xlsx&lt;/br&gt;

step 1: login to your DropBox acount.&lt;/br&gt;

step 2: create an App and generate Access Token for this app.&lt;/br&gt;

step 3: use Access Token  created at step 2 to put into DropBoxStorageAccessToken&lt;/br&gt; key value in the Web.config.&lt;/br&gt;

step 4: open WebApiExplorer project and navigate to Storage api section.&lt;/br&gt;

step 5: change "C1WebApi" to your apps name.&lt;/br&gt;

step 6: change "test.xlsx" to your file name you want to post.&lt;/br&gt;
NOTE: if using List Api, need change "test1" to your sub folder path.&lt;/br&gt;For more information, please refer sample ~\WebApi\Samples\CS</value>
  </data>
  <data name="StorageUploadPOST_PathTextGoogleDrive" xml:space="preserve">
    <value>GoogleDrive: GoogleDrive/WebAPI/test.xlsx&lt;/br&gt;

step 1: login to your GoogleDrive acount.&lt;/br&gt;

step 2: create an App and generate credentials.json file for this app.&lt;/br&gt;

step 3: usecredentials.json  created at step 2 to put into WebApi folder.&lt;/br&gt;

step 4: open WebApiExplorer project and navigate to Storage api section.&lt;/br&gt;

step 5: change "WebAPI" to your apps name.&lt;/br&gt;

step 6: change "test.xlsx" to your file name you want to post.&lt;/br&gt;
NOTE: if using List Api, need change "test1" to your sub folder path.</value>
  </data>
  <data name="StorageUploadLIST_LIST" xml:space="preserve">
    <value>List</value>
  </data>
  <data name="StorageUploadPOST_PathTextOneDrive" xml:space="preserve">
    <value>OneDrive : OneDrive/C1WebApi/test.xlsx&lt;/br&gt;

step 1: login to your OneDrive acount.&lt;/br&gt;

step 2: browse this link for access token&lt;/br&gt; "https://login.live.com/oauth20_authorize.srf?client_id=000000004C16A865&amp;scope=onedrive.readwrite&amp;response_type=token".&lt;/br&gt;

step 3: use Access Token  created at step 2 to put into OneDriveAccessToken&lt;/br&gt; key value in the Web.config.&lt;/br&gt;

step 4: open WebApiExplorer project and navigate to Storage api section.&lt;/br&gt;

step 5: change "C1WebApi" to your apps name.&lt;/br&gt;

step 6: change "test.xlsx" to your file name you want to post.&lt;/br&gt;
NOTE: if using List Api, need change "test1" to your sub folder path.</value>
  </data>
</root>